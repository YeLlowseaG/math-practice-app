<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å•è¯è®°å¿†æ¸¸æˆ - è‹±æ–‡å•è¯å­¦ä¹ </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script defer src="./assets/achievements.js"></script>
    
    <!-- é…ç½®Tailwindè‡ªå®šä¹‰é¢œè‰²å’Œå­—ä½“ -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#10B981',
                        accent: '#F59E0B',
                        danger: '#EF4444',
                        neutral: '#F7FFF7',
                        text: '#1F2937'
                    },
                    fontFamily: {
                        kids: ['"Comic Sans MS"', '"Marker Felt"', 'Arial', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            }
            .bounce-light {
                animation: bounce-light 0.5s ease infinite alternate;
            }
            .pulse-slow {
                animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }
            .scale-hover {
                transition: transform 0.2s;
            }
            .scale-hover:hover {
                transform: scale(1.05);
            }
            .correct-animation {
                animation: correct 0.6s ease-in-out;
            }
            .wrong-animation {
                animation: wrong 0.6s ease-in-out;
            }
            .level-complete {
                animation: levelComplete 1s ease-in-out;
            }
            @keyframes bounce-light {
                from { transform: translateY(0); }
                to { transform: translateY(-5px); }
            }
            @keyframes correct {
                0% { transform: scale(1); background-color: #10B981; }
                50% { transform: scale(1.1); background-color: #34D399; }
                100% { transform: scale(1); background-color: #10B981; }
            }
            @keyframes wrong {
                0% { transform: translateX(0); background-color: #EF4444; }
                25% { transform: translateX(-5px); background-color: #F87171; }
                75% { transform: translateX(5px); background-color: #F87171; }
                100% { transform: translateX(0); background-color: #EF4444; }
            }
            @keyframes levelComplete {
                0% { transform: scale(1) rotate(0deg); }
                25% { transform: scale(1.2) rotate(5deg); }
                75% { transform: scale(1.2) rotate(-5deg); }
                100% { transform: scale(1) rotate(0deg); }
            }
            @keyframes button-press {
                0% { transform: scale(1); }
                50% { transform: scale(0.95); }
                100% { transform: scale(1); }
            }
            
            .button-press {
                animation: button-press 0.2s ease-in-out;
            }
            
            .word-card {
                /* å›ºå®šæ–¹æ ¼å°ºå¯¸ï¼Œé¿å…ç¿»é¢åé«˜åº¦è·³åŠ¨ */
                aspect-ratio: 1 / 1;
                height: auto;
                overflow: hidden; /* é˜²æ­¢å†…éƒ¨å†…å®¹æ’‘é«˜å¯¼è‡´ç½‘æ ¼é«˜åº¦å˜åŒ– */
                min-width: 0; /* é¿å…ç½‘æ ¼é¡¹ä»¥å†…å®¹æœ€å°å®½åº¦æ’‘å¼€åˆ—å®½ */
                transition: all 0.3s ease;
                border: 3px solid transparent;
                display: flex;
                align-items: center; /* å‚ç›´å±…ä¸­ï¼Œç¡®ä¿æ–‡å­—å§‹ç»ˆåœ¨å¡ç‰‡ä¸­é—´ */
                justify-content: center; /* æ°´å¹³å±…ä¸­ */
            }
            .word-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
            }
            .word-card.flipped {
                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            }
            .word-card.matched {
                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                border-color: #10B981;
            }
            .word-card.wrong {
                background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
                border-color: #EF4444;
                animation: wrong 0.6s ease-in-out;
            }
            
            /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
            @media (max-width: 768px) {
                .word-card {
                    font-size: 1rem;
                    padding: 12px 8px;
                }
                .float-animation {
                    animation: none;
                }
            }
            
            @media (max-width: 480px) {
                .word-card {
                    font-size: 0.9rem;
                    padding: 10px 6px;
                }
            }
            .card-back { width: 100%; }
            /* è‹±æ–‡å•è¯ä¸æ¢è¡Œï¼Œé˜²æ­¢è¢«å¼ºåˆ¶æ‹†åˆ† */
            .card-back .word-en { white-space: nowrap; }
            /* ä¸­æ–‡ç¿»è¯‘å°½é‡ä¸€è¡Œæ˜¾ç¤º */
            .card-back .translation { white-space: nowrap; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen font-kids text-text">
    
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen" class="flex flex-col items-center justify-center min-h-screen p-8 relative">
        <!-- è¿”å›é¦–é¡µæŒ‰é’® -->
        <button onclick="window.location.href='index.html'" class="absolute top-4 right-4 bg-white/90 backdrop-blur-sm px-4 py-2 rounded-full shadow-lg transition-all duration-300 hover:scale-105 active:scale-95 text-sm font-bold text-gray-600 hover:text-gray-800 z-40">
            <i class="fa fa-home mr-2"></i>é¦–é¡µ
        </button>
        
        <div class="text-center w-full max-w-lg mx-auto bg-white rounded-3xl shadow-2xl p-6 transform transition-all duration-500">
            <h1 class="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-primary via-secondary to-accent mb-2">å•è¯è®°å¿†</h1>
            <p class="text-sm mb-3 text-gray-600">ç¿»ç‰Œé…å¯¹æ¸¸æˆ<br>è®°ä½å•è¯é…å¯¹ï¼</p>
            
            <div class="flex justify-center mb-4">
                <div class="w-16 h-16 bg-gradient-to-br from-primary to-secondary rounded-full flex items-center justify-center text-white text-2xl shadow-lg relative overflow-hidden float-animation">
                    <i class="fa fa-puzzle-piece"></i>
                    <div class="absolute inset-0 bg-white opacity-20 rounded-full animate-ping"></div>
                </div>
            </div>
            
            <!-- éš¾åº¦é€‰æ‹© -->
            <div class="mb-4">
                <h3 class="text-sm font-bold mb-2">é€‰æ‹©éš¾åº¦</h3>
                <div class="flex justify-center gap-3">
                    <button onclick="selectDifficulty('easy')" 
                            class="difficulty-btn bg-secondary/10 border-2 border-secondary/20 hover:border-secondary/40 p-2 rounded-2xl text-center scale-hover transition-all duration-300">
                        <div class="flex items-center gap-2">
                            <div class="text-xl">ğŸŒŸ</div>
                            <div class="text-left">
                                <h4 class="font-bold text-secondary leading-tight">ç®€å•</h4>
                                <p class="text-[11px] text-gray-600">3Ã—2 åŸºç¡€å•è¯</p>
                                </div>
                        </div>
                    </button>
                    <button onclick="selectDifficulty('medium')" 
                            class="difficulty-btn bg-accent/10 border-2 border-accent/20 hover:border-accent/40 p-2 rounded-2xl text-center scale-hover transition-all duration-300">
                        <div class="flex items-center gap-2">
                            <div class="text-xl">â­â­</div>
                            <div class="text-left">
                                <h4 class="font-bold text-accent leading-tight">ä¸­ç­‰</h4>
                                <p class="text-[11px] text-gray-600">4Ã—3 å¸¸ç”¨å•è¯</p>
                                </div>
                        </div>
                    </button>
                    <button onclick="selectDifficulty('hard')" 
                            class="difficulty-btn bg-danger/10 border-2 border-danger/20 hover:border-danger/40 p-2 rounded-2xl text-center scale-hover transition-all duration-300">
                        <div class="flex items-center gap-2">
                            <div class="text-xl">â­â­â­</div>
                            <div class="text-left">
                                <h4 class="font-bold text-danger leading-tight">å›°éš¾</h4>
                                <p class="text-[11px] text-gray-600">4Ã—4 è¿›é˜¶å•è¯</p>
                                </div>
                        </div>
                    </button>
                </div>
            </div>

            <!-- å…³å¡é€‰æ‹©ï¼ˆæŒ‰éœ€éšè—ï¼šå¼€å§‹é¡µä¸å±•ç¤ºå…³å¡è¿›åº¦ä¸æŒ‰é’®ï¼‰ -->
            <div class="mb-5 hidden">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-base font-bold">é€‰æ‹©å…³å¡</h3>
                    <!-- æŒ‰éœ€æ±‚ï¼šä¸åœ¨è¿™é‡Œæ˜¾ç¤ºå…³æ•°æç¤ºï¼Œç§»åˆ°æ¸¸æˆç•Œé¢æ˜¾ç¤º -->
                    <span id="level-hint" class="hidden"></span>
                </div>
                <div id="level-select" class="grid grid-cols-5 gap-2"></div>
            </div>
            
            <!-- å€’è®¡æ—¶å¼€å…³ -->
            <div class="mb-4 flex items-center justify-center gap-3 bg-gray-50 rounded-2xl p-2">
                <i class="fa fa-clock-o text-gray-600"></i>
                <span class="text-gray-700 font-medium text-sm">å€’è®¡æ—¶æ¨¡å¼</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="timer-toggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
                <span class="text-xs text-gray-500" id="timer-description">ä¸é™æ—¶æ¸¸æˆ</span>
            </div>
            
            <!-- å¾½ç« é¢„è§ˆ -->
            <div id="badge-preview" class="mb-5">
                <h3 class="text-sm font-bold mb-2">æˆ‘çš„å¾½ç« </h3>
                <div id="badge-preview-grid" class="flex justify-center gap-3 flex-wrap"></div>
                
            </div>
            
            <!-- æ¸¸æˆè¯´æ˜ -->
            <div class="mb-5">
                <div class="bg-gradient-to-r from-primary/5 to-secondary/5 rounded-xl p-4 text-sm">
                    <div class="grid grid-cols-2 gap-3">
                        <div class="flex items-center">
                            <span class="text-lg mr-2">ğŸ‘†</span>
                            <span class="text-gray-700">ç¿»å¼€å¡ç‰‡</span>
                        </div>
                        <div class="flex items-center">
                            <span class="text-lg mr-2">ğŸ¯</span>
                            <span class="text-gray-700">æ‰¾åˆ°é…å¯¹</span>
                        </div>
                        <div class="flex items-center">
                            <span class="text-lg mr-2">ğŸ”Š</span>
                            <span class="text-gray-700">å¬å‘éŸ³</span>
                        </div>
                        <div class="flex items-center">
                            <span class="text-lg mr-2">ğŸ†</span>
                            <span class="text-gray-700">å®ŒæˆæŒ‘æˆ˜</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- å¼€å§‹æ¸¸æˆæŒ‰é’® -->
            <button id="start-game-btn" onclick="startGame()" disabled
                    class="w-full bg-gradient-to-r from-primary to-secondary hover:from-secondary hover:to-primary text-white font-bold py-3 px-6 rounded-2xl shadow-lg transform transition-all duration-300 scale-hover disabled:opacity-50 disabled:cursor-not-allowed">
                å¼€å§‹æ¸¸æˆ <i class="fa fa-play ml-2"></i>
            </button>
        </div>
    </div>

    <script>
    (function(){
      const GAME_KEY = 'memory';
      const badgeDefs = [
        { id: 'first_match', name: 'é¦–é…æˆåŠŸ', icon: 'ğŸ¯' },
        { id: 'combo_5', name: 'è¿å‡»è¾¾äºº', icon: 'ğŸ”¥' },
        { id: 'speed_clear', name: 'æé€Ÿé€šå…³', icon: 'âš¡' },
        { id: 'level_master', name: 'å…³å¡é«˜æ‰‹', icon: 'ğŸ†' },
        { id: 'perfect_board', name: 'å®Œç¾å±€', icon: 'ğŸ’' }
      ];
      function getEarnedIds(){
        try { return JSON.parse(localStorage.getItem('earnedAchievements_' + GAME_KEY) || '[]'); } catch(_) { return []; }
      }
      function renderBadgePreview(){
        const grid = document.getElementById('badge-preview-grid');
        if(!grid) return;
        const owned = new Set(getEarnedIds());
        grid.innerHTML = badgeDefs.map(a => {
          const earned = owned.has(a.id);
          const base = earned ? 'from-yellow-100 to-orange-100 border-yellow-300 text-amber-900' : 'from-gray-50 to-gray-100 border-gray-200 text-gray-400 opacity-80';
          return `
            <div class="relative w-20 h-20 rounded-2xl border-2 bg-gradient-to-br ${base} shadow-sm flex flex-col items-center justify-center overflow-hidden" title="${a.name}">
              <div class="text-2xl mb-1">${a.icon}</div>
              <div class="text-[10px] font-bold text-center leading-tight px-1">${a.name}</div>
          ${earned ? '<div class=\"absolute right-1 top-1 bg-amber-400 text-white text-[10px] px-1 rounded-full shadow\">å·²è·</div>' : '<div class=\"absolute right-1 top-1 bg-gray-400 text-white text-[10px] px-1 rounded-full shadow\">æœªè·</div>'}
            </div>`;
        }).join('');
      }
      document.addEventListener('DOMContentLoaded', renderBadgePreview);
    })();
    </script>
    
    <!-- æ¸¸æˆç•Œé¢ -->
    <div id="game-screen" class="hidden flex flex-col min-h-screen p-4">
        <!-- æ¸¸æˆå¤´éƒ¨ï¼ˆå‚è€ƒåä¹‰è¯å•äººç‰ˆé£æ ¼ï¼‰ -->
        <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-lg p-3 mb-4">
            <div class="flex justify-between items-center">
                <!-- å·¦ï¼šè¿”å› + éš¾åº¦/å…³å¡èƒ¶å›Š -->
                <div class="flex items-center gap-2">
                    <button onclick="backToStart()" class="bg-white/90 backdrop-blur-sm px-3 py-2 rounded-full shadow-md transition-all duration-300 hover:scale-105 active:scale-95 text-sm font-bold text-gray-600 hover:text-gray-800">
                        <i class="fa fa-arrow-left mr-1"></i><span class="hidden sm:inline">è¿”å›</span>
                </button>
                    <div id="hud-diff-pill" class="hidden sm:flex bg-gradient-to-r from-primary to-secondary text-white px-3 py-1 rounded-full text-xs font-bold shadow">
                        <span id="hud-difficulty">-</span>
                </div>
                    <div id="hud-level-pill" class="bg-secondary text-white px-3 py-1 rounded-full text-xs font-bold shadow">
                        ç¬¬ <span id="hud-level">-</span> å…³
                </div>
                    <span id="hud-progress" class="hidden"></span>
            </div>

                <!-- ä¸­ï¼šå€’è®¡æ—¶èƒ¶å›Š -->
                <div id="wm-timer-wrap" class="hidden bg-accent text-white px-6 py-2 rounded-full shadow-md flex items-center gap-2">
                    <i class="fa fa-clock-o"></i>
                    <span id="wm-countdown" class="text-lg font-bold">--:--</span>
                </div>

                <!-- å³ï¼šå¾—åˆ†èƒ¶å›Š -->
                <div class="bg-gradient-to-r from-purple-500 to-pink-500 px-4 py-2 rounded-full text-white font-bold shadow-md flex items-center gap-2">
                    <i class="fa fa-star"></i>
                    <span id="game-score">0</span>
                </div>
                </div>

            <!-- äºŒçº§ç»Ÿè®¡ï¼šå·²é…å¯¹/æ€»å¯¹æ•°/ç¿»ç‰Œæ¬¡æ•° -->
            <div class="flex justify-center items-center gap-3 mt-2">
                <div class="bg-gray-100 px-3 py-1 rounded-full text-xs text-gray-700">
                    å·²é…å¯¹ <span id="matched-pairs" class="text-secondary font-bold ml-1">0</span>
                </div>
                <div class="bg-gray-100 px-3 py-1 rounded-full text-xs text-gray-700">
                    æ€»å¯¹æ•° <span id="total-pairs" class="text-gray-800 font-bold ml-1">0</span>
                </div>
                <div class="bg-gray-100 px-3 py-1 rounded-full text-xs text-gray-700">
                    ç¿»ç‰Œæ¬¡æ•° <span id="flip-count" class="text-accent font-bold ml-1">0</span>
                </div>
            </div>
        </div>
        
        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="flex-1 flex items-center justify-center">
            <div class="absolute top-28 left-0 right-0 flex justify-center pointer-events-none">
                <div id="wm-feedback" class="pointer-events-none"></div>
            </div>
            <div id="game-board" class="grid gap-3 bg-white rounded-2xl shadow-lg p-6">
                <!-- å¡ç‰‡å°†åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>
    
    <!-- ç»“æœç•Œé¢ -->
    <div id="result-screen" class="hidden flex flex-col items-center justify-center min-h-screen p-4">
        <div class="text-center max-w-xl mx-auto bg-white rounded-3xl shadow-2xl p-8 transform transition-all duration-300">
            <div id="result-icon" class="text-8xl mb-6 level-complete">ğŸ‰</div>
            <h2 id="result-title" class="text-3xl font-bold text-primary mb-4">æ­å–œå®Œæˆï¼</h2>
            
            <div class="bg-gradient-to-r from-primary/10 to-secondary/10 rounded-2xl p-6 mb-6">
                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center">
                        <p class="text-2xl font-bold text-primary" id="final-score">0</p>
                        <p class="text-sm text-gray-600">æœ€ç»ˆå¾—åˆ†</p>
                    </div>
                    <div class="text-center">
                        <p class="text-2xl font-bold text-secondary" id="final-flips">0</p>
                        <p class="text-sm text-gray-600">ç¿»ç‰Œæ¬¡æ•°</p>
                    </div>
                </div>
                <div class="mt-4 text-center">
                    <p id="performance-text" class="text-lg font-bold text-accent">è¡¨ç°ä¼˜ç§€ï¼</p>
                </div>
            </div>
            
            <div class="space-x-4">
                <button onclick="startGame()" 
                        class="bg-gradient-to-r from-primary to-secondary hover:from-secondary hover:to-primary text-white px-6 py-3 rounded-2xl scale-hover">
                    <i class="fa fa-refresh mr-2"></i>å†ç©ä¸€æ¬¡
                </button>
                <button id="next-level-btn" onclick="nextLevel()" 
                        class="hidden bg-secondary hover:bg-emerald-600 text-white px-6 py-3 rounded-2xl scale-hover">
                    <i class="fa fa-step-forward mr-2"></i>ä¸‹ä¸€å…³
                </button>
                <button onclick="backToStart()" 
                        class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-2xl scale-hover">
                    <i class="fa fa-home mr-2"></i>è¿”å›å¼€å§‹
                </button>
            </div>
        </div>
    </div>

    <script>
        // è°ƒè¯•å¼€å…³ä¸å·¥å…·
        const DEBUG = true; // è‹¥è¦å…³é—­æ—¥å¿—ï¼Œæ”¹ä¸º false
        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                const el = entry.target;
                logCardSize('resize', el);
            }
        });
        function logCardSize(tag, el){
            if (!DEBUG || !el) return;
            const rect = el.getBoundingClientRect();
            const cls = el.className;
            console.log(`[word-memory][${tag}] index=${el.dataset.index} word=${el.dataset.word} ` +
                `size=${Math.round(rect.width)}x${Math.round(rect.height)} classes="${cls}"`);
        }

        // ä»â€œæœ¬åœ°è¯å…¸â€ç”Ÿæˆå•è¯æ± ï¼›è‹¥è¯å…¸æœªåŠ è½½ï¼Œä¸´æ—¶ç”¨å†…ç½®å°‘é‡å…œåº•
        const fallbackWordData = {
            easy: ['cat','dog','egg','tea','sun','sky','sea','red','bus','car'],
            medium: ['chair','window','banana','butter','train','metro','music','dance','today','cloudy'],
            hard: ['computer','keyboard','television','mountain','biology','geometry','internet','website']
        };

        // æ¸¸æˆçŠ¶æ€
        let currentDifficulty = null;
        let currentLevel = 1;
        let gameBoard = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let totalPairs = 0;
        let score = 0;
        let flipCount = 0;
        let timerEnabled = true;
        let timerRef = null;
        let timeLeftSec = 0;

        // å…³å¡ä¸è¿›åº¦
        const LEVELS_PER_DIFF = 10;
        const PROGRESS_KEY = 'wordMemoryProgress';
        function loadWMProgress(){
            try{
                const raw = JSON.parse(localStorage.getItem(PROGRESS_KEY) || '{}');
                ['easy','medium','hard'].forEach(d=>{
                    if(!raw[d]) raw[d] = { unlocked: 1, completed: {} };
                });
                return raw;
            }catch(_){
                return { easy:{unlocked:1,completed:{}}, medium:{unlocked:1,completed:{}}, hard:{unlocked:1,completed:{}} };
            }
        }
        function saveWMProgress(p){ localStorage.setItem(PROGRESS_KEY, JSON.stringify(p)); }
        function renderLevelButtons(){
            const container = document.getElementById('level-select');
            const hint = document.getElementById('level-hint');
            container.innerHTML = '';
            if(!currentDifficulty){ hint.textContent = 'å…ˆé€‰æ‹©éš¾åº¦'; return; }
            const progress = loadWMProgress();
            const unlocked = progress[currentDifficulty].unlocked || 1;
            hint.textContent = `å·²è§£é”åˆ°ç¬¬ ${unlocked} å…³`;
            for(let i=1;i<=LEVELS_PER_DIFF;i++){
                const btn = document.createElement('button');
                const isUnlocked = i <= unlocked;
                const isCompleted = !!progress[currentDifficulty].completed[i];
                btn.className = `px-3 py-2 rounded-xl text-sm font-bold border transition ${isUnlocked? 'bg-white hover:bg-gray-50 border-gray-200 text-gray-700':'bg-gray-100 border-gray-200 text-gray-400 cursor-not-allowed'} ${i===currentLevel? 'ring-2 ring-primary':''}`;
                btn.textContent = `${i}` + (isCompleted? 'â˜…':'');
                if(isUnlocked){
                    btn.onclick = ()=> selectLevel(i);
                }
                container.appendChild(btn);
            }
        }
        function selectLevel(level){
            currentLevel = level;
            renderLevelButtons();
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = false;
            startBtn.classList.remove('opacity-50','cursor-not-allowed');
        }

        // æ¸¸æˆç®¡ç†å™¨
        class WordMemoryGame {
            constructor() {
                this.initSpeechSynthesis();
            }

            // åˆå§‹åŒ–è¯­éŸ³åˆæˆ
            initSpeechSynthesis() {
                this.voices = [];
                this.englishVoice = null;
                
                if ('speechSynthesis' in window) {
                    const loadVoices = () => {
                        this.voices = speechSynthesis.getVoices();
                        this.englishVoice = this.voices.find(voice => 
                            voice.lang.includes('en') && 
                            (voice.name.includes('English') || voice.lang === 'en-US')
                        ) || this.voices[0];
                        console.log('é€‰æ‹©è‹±è¯­è¯­éŸ³:', this.englishVoice?.name);
                    };

                    if (this.voices.length === 0) {
                        speechSynthesis.onvoiceschanged = loadVoices;
                    } else {
                        loadVoices();
                    }
                }
            }

            // æ’­æ”¾è‹±æ–‡å‘éŸ³  
            speak(text, rate = 0.85) {
                if (!('speechSynthesis' in window)) return;
                // å°½é‡ä½¿ç”¨å·²åŠ è½½çš„è‹±è¯­è¯­éŸ³
                const speakNow = () => {
                    const utterance = new SpeechSynthesisUtterance(text.toLowerCase());
                    utterance.voice = this.englishVoice || null;
                    utterance.lang = 'en-US';
                    utterance.rate = rate;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.95;
                    try { speechSynthesis.cancel(); } catch(_){}
                    try { speechSynthesis.speak(utterance); } catch(e){ console.warn('TTS æ’­æ”¾å¤±è´¥', e); }
                };
                if (!this.englishVoice) {
                    // ç­‰å¾…voicesåŠ è½½å†æ’­ï¼Œé¿å…é™éŸ³
                    const tryOnce = () => {
                        this.voices = speechSynthesis.getVoices();
                        this.englishVoice = this.voices.find(v => v.lang.includes('en') && (v.name.includes('English') || v.lang === 'en-US')) || this.voices[0];
                        speakNow();
                    };
                    if (speechSynthesis.getVoices().length === 0) {
                        speechSynthesis.onvoiceschanged = tryOnce;
                        // è¶…æ—¶å…œåº•
                        setTimeout(speakNow, 300);
                    } else {
                        tryOnce();
                    }
                } else {
                    speakNow();
                }
            }

            // è®°å½•å­¦ä¹ è¿›åº¦
            recordProgress(completed) {
                if (completed) {
                    const points = Math.max(100 - flipCount * 2, 20); // ç¿»ç‰Œè¶Šå°‘å¾—åˆ†è¶Šé«˜
                    score += points;
                    try { if (window.achievements) window.achievements.unlockAchievement('wm_first_clear'); } catch(_) {}
                }

                // è°ƒç”¨è¿›åº¦è®°å½•ç³»ç»Ÿ
                if (window.recordLearningProgress) {
                    window.recordLearningProgress('english', 'memory', score, 60);
                }
            }
        }

        const gameManager = new WordMemoryGame();
        // ç®€æ˜“ç¿»è¯‘è¡¨ï¼ˆå¸¸è§åŸºç¡€è¯ï¼‰
        const translations = {
            // åŠ¨ç‰©ä¸è‡ªç„¶
            cat:'çŒ«', dog:'ç‹—', pig:'çŒª', cow:'ç‰›', fox:'ç‹ç‹¸', rat:'è€é¼ ', bat:'è™è ', bee:'èœœèœ‚', ant:'èš‚èš', bug:'è™«å­',
            owl:'çŒ«å¤´é¹°', hen:'æ¯é¸¡', yak:'ç‰¦ç‰›', ape:'çŒ¿', fish:'é±¼', bird:'é¸Ÿ', horse:'é©¬', sheep:'ç¾Š', goat:'å±±ç¾Š', duck:'é¸­å­',
            sun:'å¤ªé˜³', sky:'å¤©ç©º', sea:'æµ·',

            // é£Ÿç‰©
            egg:'é¸¡è›‹', pie:'æ´¾', jam:'æœé…±', tea:'èŒ¶', ice:'å†°', ham:'ç«è…¿', nut:'åšæœ', rice:'ç±³é¥­', soup:'æ±¤', bread:'é¢åŒ…',
            water:'æ°´', juice:'æœæ±', milk:'ç‰›å¥¶', cookie:'é¥¼å¹²', pizza:'æŠ«è¨', burger:'æ±‰å ¡', salad:'æ²™æ‹‰', pasta:'æ„å¤§åˆ©é¢', chicken:'é¸¡è‚‰',
            butter:'é»„æ²¹',

            // äº¤é€š
            car:'æ±½è½¦', bus:'å…¬äº¤è½¦', train:'ç«è½¦', plane:'é£æœº', boat:'èˆ¹', bike:'è‡ªè¡Œè½¦', truck:'å¡è½¦', taxi:'å‡ºç§Ÿè½¦', metro:'åœ°é“',

            // å®¶å±…/å®¶åº­
            house:'æˆ¿å­', table:'æ¡Œå­', chair:'æ¤…å­', window:'çª—æˆ·', kitchen:'å¨æˆ¿', bedroom:'å§å®¤', garden:'èŠ±å›­', family:'å®¶åº­',
            mother:'æ¯äº²', father:'çˆ¶äº²', sister:'å§å¦¹', brother:'å…„å¼Ÿ', dinner:'æ™šé¤', breakfast:'æ—©é¤', shower:'æ·‹æµ´', toilet:'å•æ‰€',
            carpet:'åœ°æ¯¯', picture:'å›¾ç‰‡', mirror:'é•œå­', drawer:'æŠ½å±‰',

            // å­¦æ ¡/å½¢çŠ¶
            school:'å­¦æ ¡', teacher:'è€å¸ˆ', student:'å­¦ç”Ÿ', lesson:'è¯¾ç¨‹', pencil:'é“…ç¬”', paper:'çº¸', ruler:'å°ºå­', eraser:'æ©¡çš®',
            crayon:'èœ¡ç¬”', marker:'è®°å·ç¬”', book:'ä¹¦', page:'é¡µ', story:'æ•…äº‹', letter:'å­—æ¯', number:'æ•°å­—', color:'é¢œè‰²',
            shape:'å½¢çŠ¶', circle:'åœ†å½¢', square:'æ­£æ–¹å½¢', triangle:'ä¸‰è§’å½¢',

            // é¢œè‰²ä¸æ°´æœ
            red:'çº¢è‰²', blue:'è“è‰²', green:'ç»¿è‰²', apple:'è‹¹æœ', orange:'æ©™å­', grape:'è‘¡è„', banana:'é¦™è•‰', cheese:'å¥¶é…ª', cookie:'é¥¼å¹²', candy:'ç³–æœ', pizza:'æŠ«è¨', burger:'æ±‰å ¡', french:'æ³•è¯­/æ³•å›½çš„', salad:'æ²™æ‹‰', soup:'æ±¤', rice:'ç±³é¥­',

            // æ—¶é—´
            today:'ä»Šå¤©', tomorrow:'æ˜å¤©', morning:'æ—©æ™¨', evening:'å‚æ™š',

            // å¤©æ°”
            sunny:'æ™´å¤©', cloudy:'å¤šäº‘', rainy:'ä¸‹é›¨', windy:'æœ‰é£', snowy:'ä¸‹é›ª', storm:'æš´é£é›¨',

            // åŠ¨ç‰©æ‰©å±•
            mouse:'è€é¼ ', rabbit:'å…”å­', tiger:'è€è™', lion:'ç‹®å­',

            // è¿åŠ¨å¨±ä¹
            game:'æ¸¸æˆ', sport:'è¿åŠ¨', music:'éŸ³ä¹', dance:'è·³èˆ', sing:'å”±æ­Œ', play:'ç©è€', run:'è·‘æ­¥', jump:'è·³è·ƒ', swim:'æ¸¸æ³³', climb:'æ”€çˆ¬'
        };

        // é¢å¤–ï¼šå¯é€‰æœ¬åœ°å­—å…¸ï¼ˆassets/en-zh-basic.jsonï¼‰ã€‚
        // è¯´æ˜ï¼šæµè§ˆå™¨æ— æ³•ç›´æ¥è°ƒç”¨ç³»ç»Ÿè¯å…¸ï¼Œå› æ­¤ä½¿ç”¨å†…ç½® JSON æ–‡ä»¶ä½œä¸ºâ€œæœ¬åœ°è¯å…¸â€ã€‚
        let DICT = {};
        let dictLoaded = false;
        // æŒ‰éš¾åº¦åˆ†ç»„çš„è¯å…¸ç¼“å­˜
        const DICT_BY_DIFF = { easy: {}, medium: {}, hard: {} };
        async function loadLocalDictionary(){
            try{
                const res = await fetch('assets/en-zh-basic.json', { cache: 'no-cache' });
                if(res.ok){
                    DICT = await res.json();
                    dictLoaded = true;
                    // å°†è¯å…¸æŒ‰è¯é•¿ç²—åˆ†éš¾åº¦ï¼š<=4 ä¸º easyï¼Œ5-7 ä¸º mediumï¼Œå…¶ä½™ä¸º hard
                    Object.keys(DICT).forEach(w => {
                        const len = w.length;
                        const key = len <= 4 ? 'easy' : (len <= 7 ? 'medium' : 'hard');
                        DICT_BY_DIFF[key][w] = DICT[w];
                    });
                    if (DEBUG) console.log('[word-memory] local dictionary loaded, size=', Object.keys(DICT).length);
                }
            }catch(e){
                if (DEBUG) console.warn('[word-memory] load dictionary failed:', e);
            }
        }
        function getZh(word){
            const k = (word||'').toLowerCase();
            return translations[k] || DICT[k] || '';
        }
        
        // å€’è®¡æ—¶å¼€å…³é€»è¾‘
        document.getElementById('timer-toggle').addEventListener('change', function() {
            const description = document.getElementById('timer-description');
            if (this.checked) {
                description.textContent = 'æ ¹æ®éš¾åº¦é™æ—¶';
                timerEnabled = true;
            } else {
                description.textContent = 'ä¸é™æ—¶æ¸¸æˆ';
                timerEnabled = false;
            }
        });

        // åˆå§‹åŒæ­¥å¼€å…³çŠ¶æ€ â†’ è®¡æ—¶é€»è¾‘
        document.addEventListener('DOMContentLoaded', () => {
            const toggleEl = document.getElementById('timer-toggle');
            const description = document.getElementById('timer-description');
            if (toggleEl) {
                timerEnabled = !!toggleEl.checked;
                description.textContent = toggleEl.checked ? 'æ ¹æ®éš¾åº¦é™æ—¶' : 'ä¸é™æ—¶æ¸¸æˆ';
            }
        });

        // é€‰æ‹©éš¾åº¦
        function selectDifficulty(difficulty) {
            currentDifficulty = difficulty;
            // é»˜è®¤é€‰ä¸­å½“å‰éš¾åº¦ä¸‹å·²è§£é”çš„æœ€é«˜å…³
            const progress = loadWMProgress();
            currentLevel = progress[difficulty]?.unlocked || 1;
            
            // é‡ç½®æ‰€æœ‰æŒ‰é’®æ ·å¼
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('ring-4', 'ring-primary');
            });
            
            // é«˜äº®é€‰ä¸­çš„æŒ‰é’®
            event.target.closest('.difficulty-btn').classList.add('ring-4', 'ring-primary');
            
            // å¯ç”¨å¼€å§‹æŒ‰é’®
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = false;
            startBtn.classList.remove('opacity-50', 'cursor-not-allowed');

            // æ¸²æŸ“å…³å¡æŒ‰é’®
            renderLevelButtons();
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (!currentDifficulty) {
                alert('è¯·å…ˆé€‰æ‹©éš¾åº¦å’Œå…³å¡ï¼');
                return;
            }

            // è¯»å–å¼€å§‹é¡µå¼€å…³æœ€ç»ˆçŠ¶æ€
            const toggleEl = document.getElementById('timer-toggle');
            timerEnabled = toggleEl ? !!toggleEl.checked : true;

            // é‡ç½®æ¸¸æˆçŠ¶æ€
            flippedCards = [];
            matchedPairs = 0;
            score = 0;
            flipCount = 0;

            // ç”Ÿæˆæ¸¸æˆæ¿
            generateGameBoard();
            
            // åˆ‡æ¢ç•Œé¢
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            
            updateGameStats();

            // å¼‚æ­¥åŠ è½½æœ¬åœ°è¯å…¸ï¼ˆè‹¥æœªåŠ è½½ï¼‰
            if (!dictLoaded) loadLocalDictionary();

            // æ›´æ–° HUD éš¾åº¦ä¸å…³å¡
            const dmap = { easy:'ç®€å•', medium:'ä¸­ç­‰', hard:'å›°éš¾' };
            document.getElementById('hud-difficulty').textContent = dmap[currentDifficulty] || '-';
            document.getElementById('hud-level').textContent = String(currentLevel);
            document.getElementById('hud-progress').textContent = `${currentLevel}/${LEVELS_PER_DIFF}`;

            // å¯åŠ¨å€’è®¡æ—¶
            startLevelTimer();
        }

        // ä»å•è¯åº“ä¸­éšæœºé€‰æ‹©å•è¯
        function getRandomWords(difficulty, count) {
            let pool = [];
            if (dictLoaded && DICT_BY_DIFF[difficulty]) {
                pool = Object.keys(DICT_BY_DIFF[difficulty]);
            } else {
                pool = fallbackWordData[difficulty] || [];
            }
            const shuffled = [...pool].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, count);
        }
        
        // ç”Ÿæˆæ¸¸æˆæ¿
        function generateGameBoard() {
            const boardSize = {
                easy: { cols: 3, rows: 2 },
                medium: { cols: 4, rows: 3 },
                hard: { cols: 4, rows: 4 }
            };

            const { cols, rows } = boardSize[currentDifficulty];
            totalPairs = (cols * rows) / 2;
            
            // ä»å•è¯åº“éšæœºé€‰æ‹©éœ€è¦çš„å•è¯æ•°é‡
            const selectedWords = getRandomWords(currentDifficulty, totalPairs);
            
            // åˆ›å»ºå¡ç‰‡å¯¹
            const cardPairs = [];
            selectedWords.forEach(word => {
                cardPairs.push(word, word); // æ¯ä¸ªå•è¯åˆ›å»ºä¸¤å¼ å¡ç‰‡
            });
            
            // æ‰“ä¹±å¡ç‰‡
            gameBoard = cardPairs.sort(() => Math.random() - 0.5);
            
            // åˆ›å»ºæ¸¸æˆæ¿DOM
            const board = document.getElementById('game-board');
            board.innerHTML = '';
            board.className = `grid gap-3 bg-white rounded-2xl shadow-lg p-6 grid-cols-${cols}`;
            // å…ˆç”¨ fr å¸ƒå±€æ¸²æŸ“ä¸€å¸§ï¼Œéšåç”¨åƒç´ é”å®šå°ºå¯¸ï¼Œé¿å…æŠ–åŠ¨
            board.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
            
            gameBoard.forEach((word, index) => {
                const card = document.createElement('div');
                // ç§»é™¤ scale-hoverï¼Œé¿å… hover æ—¶è§†è§‰ç¼©æ”¾é€ æˆâ€œå°ºå¯¸å˜åŒ–â€çš„è§‚æ„Ÿ
                card.className = 'word-card bg-gradient-to-br from-primary to-purple-600 text-white rounded-xl cursor-pointer flex flex-col items-center justify-center p-4 text-center';
                card.innerHTML = `
                    <div class="card-front flex flex-col items-center justify-center h-full">
                        <i class="fa fa-question text-3xl mb-2"></i>
                        <p class="text-sm">ç‚¹å‡»ç¿»å¼€</p>
                    </div>
                    <div class="card-back hidden flex-col items-center justify-center h-full">
                        <p class="word-en text-2xl font-bold mb-2 leading-tight">${word}</p>
                        <p class="translation hidden text-white/90 text-sm mb-1"></p>
                        <button onclick="event.stopPropagation(); gameManager.speak('${word}')" class="bg-white bg-opacity-20 hover:bg-opacity-30 rounded-full p-1 text-sm" aria-label="æ’­æ”¾è¯»éŸ³">
                            <i class="fa fa-volume-up"></i>
                        </button>
                    </div>
                `;
                card.dataset.word = word;
                card.dataset.index = index;
                card.onclick = () => flipCard(index);
                board.appendChild(card);

                // åˆå§‹å°ºå¯¸æ—¥å¿—
                if (DEBUG) logCardSize('init', card);
                // ç›‘å¬å°ºå¯¸å˜åŒ–
                if (DEBUG) resizeObserver.observe(card);
            });

            // é”å®šå¡ç‰‡å°ºå¯¸ï¼Œé¿å…è¿è¡Œä¸­æŠ–åŠ¨ï¼›ä¸ºé¿å…æ–‡å­—æ¢è¡Œï¼Œé€‚åº¦æé«˜å•å…ƒæ ¼å°ºå¯¸ï¼ˆåŠ ä¸Šè¾¹è·ç³»æ•°ï¼‰
            requestAnimationFrame(() => lockCardSizes(cols, 1.12));
        }

        // ç¿»ç‰Œ
        function flipCard(index) {
            if (flippedCards.length >= 2) return;
            
            const card = document.querySelector(`[data-index="${index}"]`);
            if (card.classList.contains('flipped') || card.classList.contains('matched')) return;
            
            // ç¿»å¼€å¡ç‰‡
            if (DEBUG) logCardSize('before-flip', card);
            card.classList.add('flipped');
            card.querySelector('.card-front').classList.add('hidden');
            card.querySelector('.card-back').classList.remove('hidden');
            if (DEBUG) logCardSize('after-flip', card);
            flippedCards.push({ index, word: gameBoard[index], element: card });
            
            flipCount++;
            updateGameStats();
            
            // ä¸è‡ªåŠ¨æ’­æ”¾ï¼Œè®©ç”¨æˆ·ç‚¹å‡»å¡ç‰‡ä¸Šçš„æ’­æ”¾æŒ‰é’®
            
            // æ£€æŸ¥é…å¯¹
            if (flippedCards.length === 2) {
                setTimeout(checkMatch, 1000);
            }
        }

        // æ£€æŸ¥é…å¯¹
        function checkMatch() {
            const [card1, card2] = flippedCards;
            
            if (card1.word === card2.word) {
                // é…å¯¹æˆåŠŸ
                card1.element.classList.add('matched', 'correct-animation');
                card2.element.classList.add('matched', 'correct-animation');
                if (DEBUG) { logCardSize('matched-1', card1.element); logCardSize('matched-2', card2.element); }
                
                matchedPairs++;
                score += Math.max(50 - flipCount, 10);
                showWMFeedback(`å¤ªæ£’äº†ï¼+${Math.max(50 - flipCount, 10)} åˆ†`, 'success');
                
                // ä¸è‡ªåŠ¨æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
                // æ˜¾ç¤ºä¸­æ–‡ç¿»è¯‘
                [card1, card2].forEach(c => {
                    const t = c.element.querySelector('.translation');
                    if (t) {
                        const zh = getZh(c.word);
                        if (zh) {
                            t.textContent = zh;
                            t.classList.remove('hidden');
                            if (DEBUG) logCardSize('show-translation', c.element);
                        }
                    }
                });
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸ
                if (matchedPairs === totalPairs) {
                    // è¿›å…¥â€œå›çœ‹å•è¯â€çŸ­æš‚åœç•™ï¼Œå†è¿›å…¥ç»“æœé¡µï¼ˆ7ç§’ï¼‰
                    startReviewCountdown(7);
                }
            } else {
                // é…å¯¹å¤±è´¥
                card1.element.classList.add('wrong-animation');
                card2.element.classList.add('wrong-animation');
                
                setTimeout(() => {
                    // ç¿»å›å»
                    if (DEBUG) { logCardSize('before-unflip-1', card1.element); logCardSize('before-unflip-2', card2.element); }
                    card1.element.classList.remove('flipped', 'wrong-animation');
                    card1.element.querySelector('.card-front').classList.remove('hidden');
                    card1.element.querySelector('.card-back').classList.add('hidden');
                    
                    card2.element.classList.remove('flipped', 'wrong-animation');
                    card2.element.querySelector('.card-front').classList.remove('hidden');
                    card2.element.querySelector('.card-back').classList.add('hidden');
                    if (DEBUG) { logCardSize('after-unflip-1', card1.element); logCardSize('after-unflip-2', card2.element); }
                }, 800);
                showWMFeedback('å†æƒ³æƒ³ï¼', 'error');
            }
            
            flippedCards = [];
            updateGameStats();
        }

        // è®¡æ—¶ï¼šæŒ‰éš¾åº¦/å…³å¡è®¾å®šæ€»æ—¶é•¿ï¼ˆå¯è°ƒæ•´ï¼‰
        function getLevelTimeLimitSec(){
            // åŸºçº¿ï¼šeasy 90s, medium 120s, hard 150sï¼›åç»­å…³é€‚å½“å¢åŠ 
            const base = { easy: 90, medium: 120, hard: 150 }[currentDifficulty] || 120;
            const bonus = Math.min(currentLevel-1, 9) * 5; // æ¯å…³+5ç§’ä¸Šé™+45
            return base + bonus;
        }
        function startLevelTimer(){
            clearInterval(timerRef);
            const wrap = document.getElementById('wm-timer-wrap');
            const cd = document.getElementById('wm-countdown');
            if(!timerEnabled){
                wrap.classList.add('hidden');
                return;
            }
            wrap.classList.remove('hidden');
            timeLeftSec = getLevelTimeLimitSec();
            updateCountdownText();
            timerRef = setInterval(()=>{
                timeLeftSec -= 1;
                updateCountdownText();
                if(timeLeftSec <= 10){ wrap.classList.add('animate-pulse'); }
                if(timeLeftSec <= 0){
                    clearInterval(timerRef);
                    showWMFeedback('æ—¶é—´åˆ°ï¼', 'error');
                    setTimeout(gameComplete, 800);
                }
            }, 1000);
        }
        function updateCountdownText(){
            const m = Math.floor(Math.max(0,timeLeftSec)/60).toString().padStart(1,'0');
            const s = Math.floor(Math.max(0,timeLeftSec)%60).toString().padStart(2,'0');
            const cd = document.getElementById('wm-countdown');
            if(cd) cd.textContent = `${m}:${s}`;
        }
        function stopLevelTimer(){ clearInterval(timerRef); }
        
        // é¡¶éƒ¨æ¿€åŠ±åé¦ˆï¼ˆå‚è€ƒåä¹‰è¯å•äººç‰ˆé£æ ¼ï¼‰
        function showWMFeedback(text, type){
            const box = document.getElementById('wm-feedback');
            if(!box) return;
            box.className = '';
            box.textContent = text;
            box.classList.add('rounded-full','px-4','py-2','text-sm','font-bold','shadow-lg');
            if(type==='success') box.classList.add('bg-green-500','text-white');
            else if(type==='error') box.classList.add('bg-red-500','text-white');
            else box.classList.add('bg-blue-500','text-white');
            setTimeout(()=>{ box.textContent=''; box.className=''; }, 1200);
        }

        // å›çœ‹å•è¯ï¼šå®Œæˆååœç•™ N ç§’å†æ˜¾ç¤ºç»“æœ
        function startReviewCountdown(seconds){
            stopLevelTimer();
            // æ˜¾ç¤ºæç¤º
            showWMFeedback(`å…ˆçœ‹ä¸€çœ‹è¿™äº›å•è¯ï¼ˆ${seconds}sï¼‰`, 'info');
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 flex items-start justify-center pt-24 pointer-events-none';
            overlay.innerHTML = `<div class="bg-white/80 backdrop-blur-sm px-4 py-2 rounded-full text-gray-700 text-sm shadow">æ­£åœ¨å›é¡¾...</div>`;
            document.body.appendChild(overlay);
            // ç¡®ä¿æ‰€æœ‰å¡ç‰‡ä¿æŒç¿»å¼€çŠ¶æ€
            document.querySelectorAll('#game-board .word-card').forEach(el=>{
                if(!el.classList.contains('flipped')){
                    el.classList.add('flipped');
                    el.querySelector('.card-front')?.classList.add('hidden');
                    el.querySelector('.card-back')?.classList.remove('hidden');
                }
            });
            setTimeout(()=>{
                overlay.remove();
                gameComplete();
            }, Math.max(1, seconds)*1000);
        }

        // æ›´æ–°æ¸¸æˆç»Ÿè®¡
        function updateGameStats() {
            document.getElementById('game-score').textContent = score;
            document.getElementById('matched-pairs').textContent = matchedPairs;
            document.getElementById('total-pairs').textContent = totalPairs;
            document.getElementById('flip-count').textContent = flipCount;
        }

        // è®¡ç®—å¹¶é”å®šå¡ç‰‡åƒç´ å°ºå¯¸ï¼Œé¿å…ç”±äºå®¹å™¨å®½åº¦ç»†å¾®å˜åŠ¨å¼•èµ·çš„è·³åŠ¨
        function lockCardSizes(cols, scaleFactor = 1){
            const board = document.getElementById('game-board');
            if (!board) return;
            const styles = getComputedStyle(board);
            const paddingLeft = parseFloat(styles.paddingLeft) || 0;
            const paddingRight = parseFloat(styles.paddingRight) || 0;
            const columnGap = parseFloat(styles.columnGap || styles.gap) || 0;
            const boardWidth = board.clientWidth;
            const usable = boardWidth - paddingLeft - paddingRight - columnGap * (cols - 1);
            let cell = Math.floor(usable / cols);
            cell = Math.floor(cell * scaleFactor); // æ”¾å¤§ä¸€ç‚¹ï¼Œé¿å…è‹±æ–‡/ä¸­æ–‡è¢«æŒ¤æ¢è¡Œ
            board.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
            document.querySelectorAll('#game-board .word-card').forEach(el => {
                el.style.width = cell + 'px';
                el.style.height = cell + 'px';
                if (DEBUG) logCardSize('lock-size', el);
            });
            if (DEBUG) console.log(`[word-memory][lock-size] boardWidth=${boardWidth}, usable=${usable}, cell=${cell}`);
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé‡æ–°é”å®šï¼ˆé˜²æŠ–ï¼‰
        let resizeTimer = null;
        window.addEventListener('resize', () => {
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                const cols = document.querySelectorAll('#game-board .word-card').length ?
                    getComputedStyle(document.getElementById('game-board')).gridTemplateColumns.split(' ').length : 0;
                if (cols > 0) lockCardSizes(cols, 1.12);
            }, 120);
        });

        // æ¸¸æˆå®Œæˆ
        function gameComplete() {
            stopLevelTimer();
            gameManager.recordProgress(true);
            
            // æ˜¾ç¤ºç»“æœ
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-flips').textContent = flipCount;
            
            // è¯„ä¼°è¡¨ç°
            let performance = '';
            const efficiency = flipCount / (totalPairs * 2); // ç†æƒ³ç¿»ç‰Œæ¬¡æ•°çš„æ¯”ç‡
            
            if (efficiency <= 1.2) {
                performance = 'å®Œç¾ï¼è®°å¿†åŠ›è¶…å¼ºï¼';
                document.getElementById('result-icon').textContent = 'ğŸ†';
            } else if (efficiency <= 1.5) {
                performance = 'ä¼˜ç§€ï¼è¡¨ç°å¾ˆæ£’ï¼';
                document.getElementById('result-icon').textContent = 'ğŸŒŸ';
            } else if (efficiency <= 2.0) {
                performance = 'è‰¯å¥½ï¼ç»§ç»­ç»ƒä¹ ï¼';
                document.getElementById('result-icon').textContent = 'ğŸ‘';
            } else {
                performance = 'åŠ æ²¹ï¼å¤šç»ƒä¹ è®°å¿†åŠ›ï¼';
                document.getElementById('result-icon').textContent = 'ğŸ’ª';
            }
            
            document.getElementById('performance-text').textContent = performance;
            
            // åˆ‡æ¢åˆ°ç»“æœç•Œé¢
            document.getElementById('game-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.remove('hidden');

            // è®°å½•å…³å¡è¿›åº¦å¹¶æ˜¾ç¤ºâ€œä¸‹ä¸€å…³â€
            const progress = loadWMProgress();
            progress[currentDifficulty].completed[currentLevel] = true;
            if(currentLevel < LEVELS_PER_DIFF){
                progress[currentDifficulty].unlocked = Math.max(progress[currentDifficulty].unlocked, currentLevel + 1);
                document.getElementById('next-level-btn').classList.remove('hidden');
            } else {
                document.getElementById('next-level-btn').classList.add('hidden');
            }
            saveWMProgress(progress);
        }

        // è¿”å›å¼€å§‹ç•Œé¢
        function backToStart() {
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('game-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.add('hidden');
            renderLevelButtons();
        }

        // ä¸‹ä¸€å…³
        function nextLevel(){
            const progress = loadWMProgress();
            const unlocked = progress[currentDifficulty]?.unlocked || 1;
            if(currentLevel < LEVELS_PER_DIFF && currentLevel < unlocked){
                currentLevel += 1;
            }
            document.getElementById('next-level-btn').classList.add('hidden');
            startGame();
        }
    </script>
</body>
</html>